<!DOCTYPE html>
<html>
<head>	
    <title>v.1.3</title>
    <meta charset="utf-8" />
    <style>
        table {
            border: 1px solid black;
            font-family: arial, sans-serif;
            width: 100%;
        }

        td, th {
            border: 1px solid black;
            text-align: left;
            padding: 3px;
        }

        tr:nth-child(even) {
            background-color: grey;
        }

        .questiion {
            font-family: "PT Sans", Arial;
            font-size: 17px;
            font-weight: bold;
        }

        .theme {
            font-family: "PT Sans", Arial;
            font-size: 20px;
        }

        .link {
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <a href="#dotnetquestion">Общие вопросы по C#, .NET</a><br />
    <a href="#sqlquestion">Вопросы по MS SQL</a><br />
    <a href="#patternsquestion">Вопросы по шаблонам проектирования</a><br />
    <a href="#testingquestion">Вопросы по Unit Tests</a><br />
    <a href="#mvcquestion">Вопросы по ASP.NET MVC</a><br />
    <a href="#aaaa"></a>    <br />
    <div class="theme" id="dotnetquestion">Общие вопросы по C#, .NET</div>
    <div>
        <a href="#wcf">WCF</a><br />
        <a href="#oop">
            Назвать три основных свойства ООП. Рассказать про каждый из них.
            Как каждое из них реализуется на уровне C#.
        </a><br />
        <a href="#dotnet">Что такое .NET ?</a><br />
        <a href="#dll">Из чего состоит .exe или .dll файлы?</a><br />
        <a href="#serialization">Что такое сериализация и для чего она нужна?</a><br />
        <a href="#reflection">Как получить список свойств у объекта?</a><br />
        <a href="#concat">Каким образом лучше всего объединить несколько строк в одну строку?</a><br />
        <a href="#lambda">Что такое лямбда выражение?</a><br />
        <a href="#asyncawiat">Что такое async await?</a><br />
        <a href="#eventvsdelegate">Чем делегаты отлечаются от событий?</a><br />
        <a href="#staticvsnonstatic">
            Чем статические классы отличаются от нестатических? 
            Когда происходит вызов конструктора статического класса?
        </a><br />
        <a href="#paramsmethod">В чем преимущество параметризированных классов и методов?</a><br />
        <a href="#extencion">Что такое Extension методы (навески)? Для чего используются?</a><br />
        <a href="#enum">Для чего нужны перечисления (enum)?</a><br />
        <a href="#refvsvalue">Что такое ссылочные и значимые типы? В чем разница?</a><br />
        <a href="#gc">Для чего нужен сборщик мусора и как он работает?</a><br />
        <a href="#idisposable">Какую роль играет интерфейс IDisposable?</a><br />
        <a href="#synchronizethread">Как синхронизировать запрос к свойству класса из двух потоков?</a><br />
        <a href="#interfacevsabstract">В чем разница между абстрактным классом и интерфейсом?</a><br />
        <a href="#explicitvsimplicit">Чем отличается явное приведение типов от неявного?</a><br />
        <a href="#variativnost">
            List наследуется от двух интерфейсов - IList и IEnumerable.
            Почему List&lt;string&gt;можно привести к IEnumerable&lt;object&gt;, а к IList&lt;object&gt; нельзя?
        </a><br />
        <a href="#explicitinterface">
            Для чего используется объявление метода в классе явно вместе с сигнатурой интерфейса?
        </a><br />
        <a href="#nondispose">Приведите пример, как можно “засорить” память приложения?</a><br />
        <a href="#jit">Что такое JIT компилятор? Для чего он нужен?</a><br />
        <a href="#metadata">Что такое метаданные и что такое манифест?</a><br />
        <a href="#bixingunboxing">Что такое boxing and unboxing? Когда она происходит?</a><br />
        <a href="#changeprivatevar">
            * Как можно изменить private поле у объекта во время runtime в обход компилятора?
        </a><br />
        <a href="#internirovanie">Что такое Интернирование строк?</a><br />
        <a href="#concurentcollection">Потокобезопастные коллекции</a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="wcf">WCF</div>
            <div>
                Windows Communication Foundation (WCF) — программный фреймворк, используемый для обмена данными между
                приложениями, входящий в состав .NET Framework. До своего выпуска в декабре 2006 года в составе
                .NET Framework 3.0, WCF был известен под кодовым именем Indigo. WCF делает возможным построение
                безопасных и надёжных транзакционных систем через упрощённую унифицированную программную модель
                межплатформенного взаимодействия. Комбинируя функциональность существующих технологий .NET по разработке
                распределённых приложений (ASP.NET XML Web Services — ASMX, WSE 3.0, .NET Remoting,
                .NET Enterprise Services и System.Messaging), WCF предоставляет единую инфраструктуру разработки, при
                умелом применении повышающую производительность и снижающую затраты на создание безопасных, надёжных и
                транзакционных Web-служб нового поколения. Заложенные в неё принципы интероперабельности позволяют
                организовать работу с другими платформами, для чего используются технологии взаимодействия платформ,
                например WSIT, разрабатываемые на базе открытого исходного кода.
            </div>
        </li>
        <li>
            <div class="questiion" id="oop">
                Назвать три основных свойства ООП. Рассказать про каждый из них.
                Как каждое из них реализуется на уровне C#.
            </div>
            <div>
				<b>Наследование</b> - процесс в результате кт. один объект получает все свойства другого<br/>
				<b>Полиморфизм</b> - свойство, кт. позволяет использовать одно и тоже имя для решения дву и более одинаковых, но технически разных задач<br/>
				<b>Инкапсуляция</b> - механизм, кт. объединяет данные и код, манипулирует ими и защищает их от внешнего вмешательства или неправильного использования<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="dotnet">Что такое .NET ?</div>
            <div>
                <b>CLR</b> - Common Language Runtime, <b>FCL</b> - Framework Class Library
            </div>
        </li>
        <li>
            <div class="questiion" id="dll">Из чего состоит .exe или .dll файлы?</div>
            <div>
                Управляемый PE-файл состоит из 4-х частей:<br />
                заголовка PE32(+), заголовка CLR, метаданных и кода на промежуточном языке (intermediate language, IL)<br />
                Рихтер - несколько слов о метаданных
            </div>
        </li>
        <li>
            <div class="questiion" id="serialization">
                Что такое сериализация и для чего она нужна?<br />
            </div>
            <div>
                Сериализация представляет процесс преобразования какого-либо объекта в поток байтов. После преобразования
                мы можем этот поток байтов или записать на диск или сохранить его временно в памяти. А при необходимости
                можно выполнить обратный процесс - десериализацию, то есть получить из потока байтов ранее сохраненный
                объект.
            </div>
        </li>
        <li>
            <div class="questiion" id="reflection">
				Что такое рефлексия?<br/>
                Как получить список свойств у объекта?<br />
            </div>
            <div>
                <b>Рефлексия (reflection)</b> представляет собой процесс выявления типов во время выполнения приложения.<br /> Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения.<br />
                Метод FindMembers() возвращает массив объектов MemberInfo данного типа<br />
                Метод GetConstructors() возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo<br />
                Метод GetEvents() возвращает все события данного типа в виде массива объектов EventInfo<br />
                Метод GetFields() возвращает все поля данного типа в виде массива объектов FieldInfo<br />
                Метод GetInterfaces() получает все реализуемые данным типом интерфейсы в виде массива объектов Type<br />
                Метод GetMembers() возвращает все члены типа в виде массива объектов MemberInfo<br />
                Метод GetMethods() получает все методы типа в виде массива объектов MethodInfo<br />
                Метод GetProperties() получает все свойства в виде массива объектов PropertyInfo<br />
                Свойство IsAbstract возвращает true, если тип является абстрактным<br />
                Свойство IsArray возвращает true, если тип является массивом<br />
                Свойство IsClass возвращает true, если тип представляет класс<br />
                Свойство IsEnum возвращает true, если тип является перечислением<br />
                Свойство IsInterface возвращает true, если тип представляет интерфейс<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="lambda">
                Что такое лямбда выражение?<br />
            </div>
            <div>
                <b>Лямбда-выражения</b> представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют
                создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать 
                в качестве параметров в другие методы.<br/>
                Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список 
                параметров, а справа блок выражений, использующий эти параметры: (список_параметров) => выражение.<br/>
                Для написания можно использовать Action, Action&lt;in T&gt;, Func&lt;in TIn, out TOut&gt;, bool Predicate&lt;in T&gt;
            </div>
        </li>
        <li>
            <div class="questiion" id="concat">
                Каким образом лучше всего объединить несколько строк в одну строку?<br />
            </div>
            <div>
                Оператором + или string.Concat()
            </div>
        </li>
        <li>
            <div class="questiion" id="asyncawiat">
                Что такое async await?<br />
            </div>
            <div>
                Ключевое слово async указывает, что метод или лямбда-выражение являются асинхронными. Метод, помеченный
                как async должен возвращать void, Task или Task&lt;T&gt;, не может принимать в качестве своих аргументов
                параметры с модификаторами ref или out, но, при этом, он может вызывать методы, имеющие такие параметры.<br />
                Оператор await применяется к задаче в асинхронных методах, чтобы приостановить выполнение метода до
                тех пор, пока ожидаемая задача не завершится. При этом выполнение потока, в котором был вызван
                асинхронный метод, не прерывается. Метод, помеченный как await должен возвращать Task или Task&lt;T&gt;,
                может принимать в качестве своих аргументов параметры с модификаторами ref или out.
            </div>
        </li>
        <li>
            <div class="questiion" id="eventvsdelegate">
                Чем делегаты отлечаются от событий?<br />
            </div>
            <div>
                <div class="link"> https://msdn.microsoft.com/ru-ru/library/edzehd2t(v=vs.110).aspx </div>
				<b>Событие (Event)</b>
                (mdsn) Событие представляет собой сообщение, посылаемое объектом, чтобы сигнализировать о совершении
                какого-либо действия.<br />
				Event - это что-то типа property, но вместо getter'a и setter'a, у него Add и Remove. В качестве значения эти
				Add и Remove принимают метод у кт. вигнатура совпадает с сигнатурой делегата.
				<b>Делегат (Delegate)</b>
                (Richter) Тип, в котором определено событие (или экземпляры этого типа), может уведомлять другие объекты
                о некоторых особых ситуациях, которые могут случиться.<br />
                (mdsn) Делегат — это тип, содержащий ссылку на метод. Содержит конструктор и методы:<br />
				T Invoke(), IAsyncResult BeginInvoke(), void EndInvoke(IAsyncResult)<br />
				Также тип Delegate содержит пару важных статических методов:<br />
				Delegate Delegate.Combine(Delegate d1, Delegate d2) и Delegate Delegate.Remove(Delegate d1, Delegate d2)  
            </div>
        </li>
        <li>
            <div class="questiion" id="staticvsnonstatic">
                Чем статические классы отличаются от нестатических? Когда происходит вызов конструктора статического
                класса?
            </div>
				Если посмотреть на IL код, то мы увидим, что static это комбинация abstract и sealed. отсюда вытекает ...<br/>
				Вызов конструктора статического класса происходит при первом обращении к этому Типу.
            <div>
            </div>
        </li>
        <li>
            <div class="questiion" id="paramsmethod">
                В чем преимущество параметризированных классов и методов?<br />
            </div>
            <div>
				Они могут работать с любыми типами. Проще говоря мы используем один и тот же алгоритм для разных типов.
            </div>
        </li>
        <li>
            <div class="questiion" id="extencion">
                Что такое Extension методы (навески)? Для чего используются?<br />
            </div>
            <div>
				<b>Методы расширения (extension methods)</b> позволяют добавлять новые методы в уже существующие типы без создания нового производного класса. Эта функциональность бывает особенно полезна, когда нам хочется добавить 
				в некоторый тип новый метод, но сам тип (класс или структура) мы изменить не можем.
            </div>
        </li>
        <li>
            <div class="questiion" id="enum">
                Для чего нужны перечисления (enum)?<br />
            </div>
            <div>
                Набор именованных констант
            </div>
        </li>
        <li>
            <div class="questiion" id="refvsvalue">
                Что такое ссылочные и значимые типы? В чем разница?<br />
            </div>
            <div>
                CLR поддерживает две разновидности типов:<br />
                <b>Ссылочные типы (reference types)</b><br />
                Память для ссылочных типов всегда выделяется из управляемой кучи, а оператор C# new возвращает адрес в
                памяти, где размещается сам объект.Память для ссылочных типов всегда выделяется из управляемой кучи;
                каждый объект, размещаемый в куче, содержит дополнительные члены, подлежащие инициализации; незанятые
                полезной информацией байты объекта обнуляются (это касается полей); размещение объекта в управляемой куче
                со временем инициирует сборку мусора.<br />
                <b>Значимые типы (value types)</b><br />
                Экземпляры этих типов обычно размещаются в стеке потока. В представляющей экземпляр переменной нет
                указателя на экземпляр; поля экземпляра размещаются в самой переменной. Все структуры являются прямыми
                потомками абстрактного типа System.ValueType. Все перечисления являются производными от типа System.Enum,
                производного от System.ValueType.<br />
                Важнейшие отличия:<br />
                1. Объекты значимого типа существуют в двух формах (см. следующий раздел): неупакованной (unboxed) и
                упакованной (boxed). Ссылочные типы бывают только в упакованной форме.<br />
                2. Значимые типы являются производными от System.ValueType. Этот тип имеет те же методы, что и
                System.Object. Однако System.ValueType переопределяет метод Equals, который возвращает true, если значения
                полей в обоих объектах совпадают. Кроме того, в System.ValueType переопределен метод GetHashCode, который
                создает хеш-код по алгоритму, учитывающему значения полей экземпляра объекта. Из-за проблем с
                производительностью в реализации по умолчанию, определяя собственные значимые типы значений, надо
                переопределить и написать свою реализацию методов Equals и GetHashCode. О методах Equals и GetHashCode
                рассказано в конце этой главы.<br />
                3. Поскольку в объявлении нового значимого или ссылочного типа нельзя указывать значимый тип в качестве
                базового класса, создавать в значимом типе новые виртуальные методы нельзя. Методы не могут быть
                абстрактными и неявно являются запечатанными (то есть их нельзя переопределить).<br />
                4. Переменные ссылочного типа содержат адреса объектов в куче. Когда переменная ссылочного типа создается,
                ей по умолчанию присваивается null, то есть в этот момент она не указывает на действительный объект.
                Попытка задействовать переменную с таким значением приведет к генерации исключения NullReferenceException.
                В то же время в переменной значимого типа всегда содержится некое значение соответствующего типа, а при
                инициализации всем членам этого типа присваивается 0. Поскольку переменная значимого типа не является
                указателем, при обращении к значимому типу исключение NullReferenceException возникнуть не может. CLR
                поддерживает понятие значимого типа особого вида, допускающего присваивание null (nullable types). Этот
                тип обсуждается в главе 19.<br />
                5. Когда переменной значимого типа присваивается другая переменная значимого типа, выполняется
                копирование всех ее полей. Когда переменной ссылочного типа присваивается переменная ссылочного типа,
                копируется только ее адрес.<br />
                6. Вследствие сказанного в предыдущем пункте несколько переменных ссылочного типа могут ссылаться на один
                объект в куче, благодаря чему, работая с одной переменной, можно изменить объект, на который ссылается
                другая переменная. В то же время каждая переменная значимого типа имеет собственную копию данных
                «объекта», поэтому операции с одной переменной значимого типа не влияют на другую переменную.<br />
                7. Так как неупакованные значимые типы не размещаются в куче, отведенная для них память освобождается
                сразу при возвращении управления методом, в котором описан экземпляр этого типа (в отличие от ожидания
                уборки мусора).
            </div>
        </li>
        <li>
            <div class="questiion" id="gc">
                Для чего нужен сборщик мусора и как он работает?<br />
            </div>
            <div>
                CLR использует алгоритм отслеживания ссылок. Все переменные ссылочных типов называются корнями (roots).<br />
                Когда среда CLR запускает уборку мусора, она сначала приостанавливает все программные потоки в процессе,
                а затем определяет поколения, в которых нужно выполнить уборку мусора.<br />
                Затем CLR переходит к этапу уборки мусора, называемому маркировкой (marking). CLR перебирает все объекты в
                куче, задавая биту в поле индекса блока синхронизации значение 0. Это означает, что все эти объекты могут
                быть удалены. Затем CLR проверяет все активные корни и объекты, на которые они ссылаются. Если корень
                содержит null, CLR игнорирует его и переходит к следующему корню. Если корень ссылается на объект, в поле
                индекса блока синхронизации устанавливается бит — это и есть признак маркировки объекта. После маркировки
                объекта CLR проверяет все корни в этом объекте и маркирует объекты, на которые они ссылаются. Встретив уже
                маркированный объект, уборщик мусора останавливается, чтобы избежать возникновения бесконечного цикл
                сылок.<br />
                После проверки всех корней куча содержит набор маркированных и немаркированных объектов. Маркированные
                объекты переживут уборку мусора, потому что на них ссылается хотя бы один объект; можно сказать, что они
                достижимы из кода приложения. Немаркированные объекты недостижимы, потому что в приложении не существует
                корня, через который приложение могло бы к ним обратиться.<br />
                Теперь, когда CLR знает, какие объекты должны остаться, а какие можно удалить, начинается следующая фаза
                уборки мусора, называемая сжатием (compacting phase). В этой фазе CLR перемещает вниз все «немусорные»
                объекты, чтобы они занимали смежный блок памяти. После перемещения в памяти все ссылки на «выжившие»
                объекты обновляются, это означает, что CLR вычитает из каждого корня количество байт, на которое объект
                был сдвинут в памяти. Тем самым гарантируется, что каждый корень будет ссылаться на тот же объект, что и
                прежде. После сжатия памяти кучи в указатель NextObjPtr управляемой кучи заносится первый адрес за
                последним объектом, не являющимся мусором.<br />
                Если CLR не удается освободить память в результате уборки мусора, а в процессах не осталось адресного
                пространства для выделения нового сегмента, значит, свободная память процесса полностью исчерпана. В этом
                случае попытка выделения новой памяти оператором new приведен к выдаче исключения OutOfMemoryException.<br />
                Для работы с объектами, имеющими метод Finalize, CLR использует следующий механизм. При создании объекта,
                если он содержит метод Finalize, ссылка на него помещается в специальный список, называемый Finalization
                Queue.<br />
                После того, как GC определяет, что какой-либо объект можно удалить, ссылка на этот объект ищется в
                Finalization Queue, и если находится, то объект оставляется в покое до следующей сборки мусора, а ссылка
                на него из Finalization Queue удаляется и добавляется в другой список, называемый F-reachable Queue.<br />
                Далее этим списком занимается специально созданный для этого поток, который по очереди вызывает методы
                Finalize для объектов из F-reachable Queue, а затем удаляет их и из этого списка.
            </div>
        </li>
        <li>
            <div class="questiion" id="idisposable">Какую роль играет интерфейс IDisposable?</div>
            <div>
                Для очистки ресурсов после их использования.<br />
                using(StreamReader sr = new StreamReader(filename)){
                <br />&nbsp;&nbsp;xt = sr.ReadToEnd();<br />
                }<br />
                StreamReader sr = null;<br />
                try {
                <br />&nbsp;&nbsp;sr = new StreamReader(filename);
                <br />&nbsp;&nbsp;txt = sr.ReadToEnd();<br />
                }<br />
                finally {
                <br />&nbsp;&nbsp;if (sr != null) sr.Dispose();<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="synchronizethread">
                Как синхронизировать запрос к свойству класса из двух потоков?<br />
            </div>
            <div>
                Есть 2 вида синхронизации потоков:<br />
                пользовательский режим<br />
                Volatile. Volatile.Read И Volatile.Write<br />
                Interlocked. Много всяких методов<br />
                режим ядра<br />
                - Monitor (Статический класс)<br />
                - EventWaitHandle<br />
                - Mutex<br />
                - Semaphor<br />
                - AutoResetEvent – типа турникет<br />
                - ManualResetEvent – типа шлагбаум<br />
                - lock – аналог следующего кода<br />
                Boolean lockTaken = false;<br />
                try {<br />
                &nbsp;&nbsp;Monitor.Enter(this, ref lockTaken);<br />
                &nbsp;&nbsp;// Этот код имеет монопольный доступ к данным...<br />
                }<br />
                finally {<br />
                &nbsp;&nbsp;if (lockTaken) Monitor.Exit(this);<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="interfacevsabstract">
                В чем разница между абстрактным классом и интерфейсом?<br />
            </div>
            <div>
                0. АК – наследуется; И – реализуется.<br />
                1. Модификаторы доступа<br />
                2. И – нельзя объявлять поля<br />
                3. И – нельзя объявлять конструктор<br />
                4. И – нельзя объявлять статические члены<br />
                5. И – нельзя реализовать тело метода<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="explicitvsimplicit">
                Чем отличается явное приведение типов от неявного?<br />
            </div>
            <div>
				Явное приведение считается небезопастным<br/>
				Неявное приведение считается безопастным<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="variativnost">
                List наследуется от двух интерфейсов - IList и IEnumerable. Почему List&lt;string&gt;можно привести к
                IEnumerable&lt;object&gt;, а к IList&lt;object&gt; нельзя?<br />
            </div>
            <div>
                <div class="link"> http://professorweb.ru/my/csharp/charp_theory/level11/11_14.php </div>
                <b>Ковариативность</b> – out, значит указанный тип является максимальным в цепочке наследования, кт. могут 
                передаваться<br/>
                <b>Контравариативность</b> – in, значит указанный тип является минимальным в цепочке наследования, кт. могут 
                передаваться<br/>
                <b>Инвариативность</b> – что указал, то и есть.<br />
                <div class="link"> https://habrahabr.ru/post/218753/ </div>
            </div>
        </li>
        <li>
            <div class="questiion" id="explicitinterface">
                Для чего используется объявление метода в классе явно вместе с сигнатурой интерфейса?<br />
            </div>
            <div>
                Чтобы вызвать этот метод через интерфейсную ссылку. При ясной реализации метода, он по умолчанию
                private
            </div>
        </li>
        <li>
            <div class="questiion" id="nondispose">
                Приведите пример, как можно “засорить” память приложения?<br />
            </div>
            <div>

            </div>
        </li>
        <li>
            <div class="questiion" id="jit">
                Что такое JIT компилятор? Для чего он нужен?<br />
            </div>
            <div>
                Это just-in-time компилятор кт. компилирует код в процессе его выполнения.<br />
                Для компилирования IL-кода в процессе работы приложения.<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="metadata">
                Что такое метаданные и что такое манифест?<br />
            </div>
            <div>
                <b>Метаданные</b> — это блок двоичных данных, состоящий из нескольких таблиц. Существуют три категории таблиц:
                определений, ссылок и манифестов<br />
                Рихтер - несколько слов о метаданных<br />
                Файл Program.exe — это не просто PE-файл с метаданными, а еще и сборка (assembly), то есть совокупность
                одного или нескольких файлов с определениями типов и файлов ресурсов. Один из файлов сборки выбирается
                для хранения ее манифеста. Манифест (manifest) — это еще один набор таблиц метаданных, которые в основном
                содержат имена файлов, составляющих сборку. Кроме того, эти таблицы описывают версию и региональные
                стандарты сборки, ее издателя, общедоступные экспортируемые типы, а также все составляющие сборку файлы.
                <br />Рихтер - Объединение модулей для создания сборки
            </div>
        </li>
        <li>
            <div class="questiion" id="bixingunboxing">
                Что такое boxing and unboxing? Когда она происходит?<br />
            </div>
            <div>
                --Упаковка<br />
                Для преобразования значимого типа в ссылочный служит упаковка (boxing). При упаковке экземпляра значимого
                типа происходит следующее.<br />
                1. В управляемой куче выделяется память. Ее объем определяется длиной значимого типа и двумя
                дополнительными членами — указателем на типовой объект(type object pointer) и индексом блока
                синхронизации(syncblock index). Эти члены необходимы для всех объектов в управляемой куче.<br />
                2. Поля значимого типа копируются в память, только что выделенную в куче.<br />
                3. Возвращается адрес объекта. Этот адрес является ссылкой на объект, то есть значимый тип превращается
                в ссылочный.<br />
                --Распаковка<br />
                Point p = (Point) a[0];<br />
                Здесь ссылка (или указатель), содержащаяся в элементе с номером 0 массива ArrayList, помещается в <br />
                переменную p значимого типа Point. Для этого все поля, содержащиеся в упакованном объекте Point, надо
                скопировать в переменную p значимого типа, находящуюся в стеке потока. CLR выполняет эту процедуру в два
                этапа.<br />
                1. Сначала извлекается адрес полей Point из упакованного объекта Point. Этот процесс называют
                распаковкой (unboxing).<br />
                2. Затем значения полей копируются из кучи в экземпляр значимого типа, находящийся в стеке.<br />
                Распаковка не является точной противоположностью упаковки. Она гораздо менее ресурсозатратна, чем
                упаковка, и состоит только в получении указателя на исходный значимый тип (поля данных), содержащийся в
                объекте. В сущности, указатель ссылается на неупакованную часть упакованного экземпляра, и никакого
                копирования при распаковке (в отличие от упаковки) не требуется. Однако вслед за распаковкой обычно
                выполняется копирование полей.<br />
                При распаковке упакованного значимого типа происходит следующее.<br />
                1. Если переменная, содержащая ссылку на упакованный значимый тип, равна null, генерируется исключение
                NullReferenceException.<br />
                2. Если ссылка указывает на объект, не являющийся упакованным значением требуемого значимого типа,
                генерируется исключение InvalidCastException.<br />
                Из второго пункта следует, что приведенный ниже код не работает так, как хотелось бы:<br />
                public static void Main()<br />
                {<br />
                &nbsp;&nbsp;Int32 x = 5;<br />
                &nbsp;&nbsp;Object o = x; // Упаковка x; o указывает на упакованный объект<br />
                &nbsp;&nbsp;Int16 y = (Int16) o; // Генерируется InvalidCastException<br />
                &nbsp;&nbsp;Int16 y = (Int16)(Int32) o; // Распаковка, а затем приведение типа<br />
                }<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="changeprivatevar">
                * Как можно изменить private поле у объекта во время runtime в обход компилятора?<br />
            </div>
            <div>
				С помощью рефлексии
            </div>
        </li>
        <li>
            <div class="questiion" id="internirovanie">
                Что такое Интернирование строк?<br />
            </div>
            <div>
                <b>Интернирование строк</b> — это механизм, при котором одинаковые литералы представляют собой один объект в
                памяти. В рамках процесса (именно процесса, а не домена приложения) существует одна внутренняя
                хеш-таблица, ключами которой являются строки, а значениями – ссылки на них. Во время JIT-компиляции
                литеральные строки последовательно заносятся в таблицу (каждая строка в таблице встречается только один
                раз). На этапе выполнения ссылки на литеральные строки присваиваются из этой таблицы. Можно поместить
                строку во внутреннюю таблицу во время выполнения с помощью метода String.Intern. Также можно проверить,
                содержится ли строка во внутренней таблице с помощью метода String.IsInterned.
            </div>
        </li>
        <li>
            <div class="questiion" id="concurentcollection">
                Потокобезопастные коллекции<br />
            </div>
            <div>
                ConcurrentQueue&lt;T&gt;<br />
                Этот класс коллекции реализован со свободным от блокировок алгоритмом и использует 32 массива, которые
                внутренне скомбинированы в связный список. Для доступа к элементам очереди применяются методы Enqueue(),
                TryDequeue() и TryPeek(). Имена этих методов очень похожи на уже известные методы Queue&lt;T&gt;
                , но с добавлением префикса Try к тем из них, которые могут дать сбой. Поскольку этот класс реализует
                интерфейс IProducerConsumerCollection&lt;T&gt;, методы TryAdd() и TryTake() просто вызывают Enqueue() и
                TryDequeue().<br />
                ConcurrentStack&lt;T&gt;<br />
                Очень похож на ConcurrentQueue&lt;T&gt;, но с другими методами доступа к элементам. Класс
                ConcurrentStack&lt;T&gt; определяет методы Push(), PushRange(), TryPeek(), TryPop() и TryPopRange().
                Внутри этот класс использует связный список для хранения элементов. ConcurrentBag&lt;T&gt;Этот класс не
                определяет никакого порядка для добавления или извлечения элементов. Он реализует концепцию отображения
                потоков на используемые внутренне массивы, и старается избежать блокировок. Для доступа к элементам
                применяются методы Add(), TryPeek() и TryTake().<br />
                ConcurrentDictionary&lt;TKey, TValue&gt;<br />
                Безопасная в отношении потоков коллекция ключей и значений. Для доступа к членам в неблокирующем режиме
                служат методы TryAdd(), TryGetValue(), TryRemove() и TryUpdate(). Поскольку элементы основаны на ключах и
                значениях, ConcurrentDictionary&lt;TKey, TValue&gt; не реализует интерфейс
                IProducerConsumerCollection&lt;T&gt;.<br />
                ConcurrentXXX<br />
                Эти коллекции безопасны к потокам в том смысле, что возвращают false, если какое-то действие над ними
                невозможно при текущем состоянии потоков. Прежде чем предпринимать какие-то дальнейшие действия, всегда
                следует проверять успешность добавления или извлечения элементов. Полностью доверять коллекции решение
                задачи нельзя.<br />
                BlockingCollection&lt;T&gt;<br />
                Коллекция, которая осуществляет блокировку и ожидает, пока не появится возможность выполнить действие по
                добавлению или извлечению элемента. BlockingCollection&gt;T&gt; предлагает интерфейс для добавления и
                извлечения элементов методами Add() и Take(). Эти методы блокируют поток и затем ожидают, пока не
                появится возможность выполнить задачу. Метод Add() имеет перегрузку, которой можно также передать
                CancellationToken. Эта лексема всегда отменяет блокирующий вызов. Если не нужно, чтобы поток ожидал
                бесконечное время, и не хотите отменять вызов извне, доступны также методы TryAdd() и TryTake(). В них
                можно указать значение таймаута — максимального периода времени, в течение которого вы готовы блокировать
                поток и ждать, пока вызов не даст сбой.
            </div>
        </li>
    </ul>

    <div class="theme" id="sqlquestion">Вопросы по MS SQL</div>
    <div>
        <a href="#tsql">Что такое T-SQL?</a><br />
        <a href="#normalization">Нормализация</a><br />
        <a href="#temptable">Temp table</a><br />
        <a href="#isolation">Виды изоляций транзакций?</a><br />
        <a href="#spvsudf">Что такое хранимая процедура? В чем отличие от функции?</a><br />
        <a href="#view">Что такое View</a><br />
        <a href="#heap">Расскажите про Кучу?</a><br />
        <a href="#indexes">Что такое индексы? Какие типы индексов вы знаете? Для чего нужны?</a><br />
        <a href="#clustered">Расскажите про структуру кластерного индекса?</a><br />
        <a href="#nonclustered">Расскажите про структуру некластерного индекса?</a><br />
        <a href="#columnstore">Расскажите про columnstore index?</a><br />
        <a href="#xmlindex">Расскажите про XML index?</a><br />
        <a href="#otherindexes">Какие еще типы индексов вы знаете?</a><br />
        <a href="#constraint">Что такое Constraint? Какие Constraint вам известны и какую роль они выполняют?</a><br />
        <a href="#triggers">Что такое триггеры?</a><br />
        <a href="#joins">Что такое LEFT JOIN, RIGHT JOIN, INNER JOIN</a><br />
        <a href="#hints">Для чего нужны hints (подсказки или указания) в sql?</a><br />
        <a href="#scantable">Что такое Full Table Scan? Как этого можно избежать?</a><br />
        <a href="#sqltransaction">Что дает SQL транзакция?</a><br />
        <a href="#denormalization">
            Для чего используется денормализация базы данных?
            Приходилось ли вам денормализировать базу данных?
        </a><br />
        <a href="#computedcolumn">
            Расскажите, из чего состоит строка в таблице, содержащей две колонки типа nvarchar и int?
            Какие дополнительные данные содержатся в этой строке?
        </a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="tsql">
                Что такое T-SQL?
            </div>
            <div>
                <b>Transact-SQL (T-SQL)</b> — процедурное расширение языка SQL, созданное компанией Microsoft (для Microsoft SQL Server) и Sybase (для Sybase ASE).
            </div>
        </li>
        <li>
            <div class="questiion" id="normalization">Нормализация</div>
            <div>
                <div class="link"> https://habrahabr.ru/post/254773/ </div>
                <b>Атрибут</b> — свойство некоторой сущности. Часто называется полем таблицы.<br />
                <b>Домен атрибута</b> — множество допустимых значений, которые может принимать атрибут.<br />
                <b>Кортеж</b> — конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе
                описывают некоторую сущность (строка таблицы).<br />
                <b>Отношение</b> — конечное множество кортежей (таблица).<br />
                <b>Первая нормальная форма</b><br />
                Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны
                содержать только скалярные значения. Не должно быть повторений строк в таблице.<br />
                <b>Вторая нормальная форма</b><br />
                Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от
                Первичного Ключа(ПК).<br />
                Проще говоря, второе правило требует выносить все не ключевые поля, содержимое которых может относиться к
                нескольким записям таблицы в отдельные таблицы.<br />
                <b>Третья нормальная форма</b><br />
                Отношение находится в 3НФ, когда находится во 2НФ и каждый не ключевой атрибут нетранзитивно зависит от
                первичного ключа.
            </div>
        </li>
        <li>
            <div class="questiion" id="temptable">Temp table</div>
            <div>
				Temptable бывают следующих видов:<br/>
				- #tempTable - хранятся в tempDB, не может использоваться повторно<br/>
				- ##tempTable - хранятся в tempDB, но может использоваться повторно<br/>
				- @tempTable - табличная переменная. Время жизни - это рамки процедуры или функции
            </div>
        </li>
        <li>
            <div class="questiion" id="isolation">Виды изоляций транзакций?</div>
            <div>
                <div class="link"> https://habrahabr.ru/company/infopulse/blog/261097/ </div>
                <b>
                    Read Uncommitted<br />
                    Проблема – Lost Update<br />
                </b>
                Две транзакции выполняют одновременно UPDATE для одной и той же строки, и изменения, сделанные одной
                транзакцией, затираются другой.<br />
                <table>
                    <tr>
                        <th style="">tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>UPDATE tbl1 SET f2=f2+20 WHERE f1=1;</td>
                        <td>UPDATE tbl1 SET f2=f2+10 WHERE f1=1;</td>
                    </tr>
                </table>
                <b>
                    Read Committed (Default)<br />
                    Проблема - Dirty read<br />
                </b>
                Это такое чтение, при котором могут быть считаны добавленные или изменённые данные из другой транзакции,
                которая впоследствии не подтвердится (откатится). Так как данный эффект возможен только при минимальном
                уровне изоляции, а по умолчанию используется более высокий уровень изоляции (READ COMMITTED), то в
                скрипте чтения данных уровень изоляции будет явно установлен как READ UNCOMMITTED. Если вернуть уровень
                изоляции по умолчанию (READ COMMITTED) для транзакции 2, то поведение поменяется.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>UPDATE</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>SELECT</td>
                    </tr>
                    <tr>
                        <td>ROLLBACK</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>SELECT</td>
                    </tr>
                </table>
                <b>
                    Repeatable Read<br />
                    Проблема – non-repeatable read<br />
                </b>
                Проявляется, когда при повторном чтении в рамках одной транзакции, ранее прочитанные данные, оказываются
                изменёнными. Данный эффект может наблюдаться при уровне изоляции ниже, чем REPEATABLE READ.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>UPDATE</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>COMMIT</td>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                </table>
                <b>
                    Serializable<br />
                    Проблема – phantom reads<br />
                </b>
                Можно наблюдать, когда одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по
                одним и тем же критериям. При этом другая транзакция в интервалах между этими выборками добавляет или
                удаляет строки, или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции,
                и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные
                множества строк. Данный эффект можно наблюдать, когда уровень изоляции ниже чем SERIALIZABLE.<br />
                <table>
                    <tr>
                        <th>tr#1</th>
                        <th>tr#2</th>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>INSERT</td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>COMMIT</td>
                    </tr>
                    <tr>
                        <td>SELECT</td>
                        <td></td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="spvsudf">Что такое хранимая процедура? В чем отличие от функции?</div>
            <div>
                <b>хранимая процедура</b> - упорядоченная последовательность операторов T-SQL, оформленных в виде единого
                логического модуля. В ХП допускается использование переменных и параметров, а также операторов управления
                ходом выполнения и циклических конструкций.<br />
                <b>UDF</b> - это подпрограмма, которая принимает на вход параметры, обрабатывает их и возвращает результат.
                Результат может быть как скаляром, так и таблицей.
                <div class="link"> http://stackoverflow.com/questions/1179758/function-vs-stored-procedure-in-sql-server </div>
                A Function can be used inline in SQL Statements if it returns a scalar value or can be joined upon if
                it returns a result set.
                Functions are computed values and cannot perform permanent environmental changes to SQL Server
                (i.e. no INSERT or UPDATE statements allowed).
                The difference between SP and UDF is listed below:
                <table>
                    <tr>
                        <th>Stored Procedure (SP)</th>
                        <th>Function (UDF - User Defined Function)</th>
                    </tr>
                    <tr>
                        <td>We can't use SP in SELECT/WHERE/ HAVING statement</td>
                        <td>We can use UDF in SELECT/WHERE/ HAVING statement</td>
                    </tr>
                    <tr>
                        <td>SP can use update, insert, delete</td>
                        <td>Functions are computed values</td>
                    </tr>
                    <tr>
                        <td>SP can return zero, single or multiple values</td>
                        <td>Function can return one value which is mandatory</td>
                    </tr>
                    <tr>
                        <td>We can use transaction in SP</td>
                        <td>We can't use transaction in UDF</td>
                    </tr>
                    <tr>
                        <td>SP can have input/output parameter</td>
                        <td>Only input parameter</td>
                    </tr>
                    <tr>
                        <td>We can call function from SP.</td>
                        <td>We can't call SP from function</td>
                    </tr>
                    <tr>
                        <td>We can use exception handling using Try-Catch block in SP</td>
                        <td>We can't use Try-Catch block in UDF</td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="view">Что такое View?</div>
            <div>
                <b>Представление (view)</b> — это объект реляционной базы данных, который описывает виртуальную
                таблицу.<br />
                <b>Представление (view)</b> — это хранимый запрос SELECT любой сложности, при выполнении которого
                получается виртуальная таблица, которая физически в базе данных не хранится.<br />
                При использовании представления можно изменять данные в базовых таблицах представления.<br />
                Изменениям подлежат только значения "обычных" столбцов.<br />
                Нельзя изменить значение вычисляемого столбца.<br />
                Разумеется, нет возможности внести изменения в данные, полученные при помощи агрегатных функций.<br />
                Нельзя при помощи представления добавить новую строку в базовую таблицу, если в списке выбора не
                присутствуют все столбцы, входящие в состав первичного ключа. При этом если первичный ключ описан с
                характеристикой IDENTITY и он не присутствует в списке выбора представления, то добавление новых строк
                возможно.<br />
                Представления могут быть индексированными. Для представления допустимо создание уникального
                кластерного индекса. В этом случае результирующий набор данных представления будет физически
                храниться в базе данных. Изменения в базовой таблице, связанные со столбцами, входящими в состав
                такого индекса, приведут к выполнению соответствующих изменений в индексе.<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="heap">Расскажите про Кучу?</div>
            <div>
                <b>Кучи</b> – это данные, хранящиеся без какой-либо определенной сортировки, не имеющие кластерных индексов,
                доступ и поиск по таким данным происходит последовательно при сканировании страниц, и может занимать
                довольно долгое время влияя негативно на производительность.
            </div>
        </li>
        <li>
            <div class="questiion" id="indexes">Что такое индексы? Какие типы индексов вы знаете? Для чего нужны?</div>
            <div>
                <b>Индекс (англ. index)</b> — объект базы данных, создаваемый с целью повышения производительности
                поиска данных.<br />
                - Clustered Index — кластерный индекс;<br />
                - Non-Clustered Index — некластерный индекс;<br />
                - Columnstore index - индекс для столбцов;<br />
                - XML index - индекс для XML;<br />
                <div class="link"> https://habrahabr.ru/post/247373/ </div>
            </div>
        </li>
        <li>
            <div class="questiion" id="clustered">Расскажите про структуру кластерного индекса?</div>
            <div>
                <b>Кластеризованный индекс</b> организован в виде сбалансированного дерева и хранит реальные строки
                данных в листьях индекса. Важной характеристикой кластеризованного индекса является то, что все
                значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица
                или представление может иметь только один кластеризованный индекс. В дополнение следует отметить, что
                данные в таблице хранятся в отсортированном виде только в случае если создан кластеризованный индекс у
                этой таблицы.
            </div>
        </li>
        <li>
            <div class="questiion" id="nonclustered">Расскажите про структуру некластерного индекса?</div>
            <div>
                <b>Некластеризованный индекс</b> организован в виде сбалансированного дерева и не содержит реальных
                данных таблицы в узлах-листьях. Это означает, что системе подзапросов необходима дополнительная
                операция для обнаружения и получения требуемых данных. Содержание указателя на данные зависит от
                способа хранения данных: <b>кластеризованная таблица или куча</b>.<br />
                1 - Если в таблице не создан кластеризованный индекс, то некластеризованные индексы по этой таблице
                хранят в своих узлах-листьях <b>идентификаторы строк</b>. Идентификатор строки указывает на реальную строку
                данных в таблице, по сути это - значение, включающее в себя номер файла данных, номер страницы и
                местоположение строки на этой странице.<br />
                2 - Если в таблице создан кластеризованный индекс, то некластеризованные индексы содержат в узле-листе
                <b>значение ключа кластеризованного индекса</b> для этих данных. При достижении узла-листа некластеризованного
                индекса находящееся в нем значение кластеризованного ключа используется для поиска в кластеризованном
                индексе, соответствующий узел-лист которого содержит искомую строку данных.<br>
                Возможно, создать до 999 некластеризованных индексов на одну таблицу.
            </div>
        </li>
        <li>
            <div class="questiion" id="columnstore">Расскажите про columnstore index?</div>
            <div>
                <b>Columnstore index</b><br />
                <b>Индексы columnstore</b> появились в версии SQL Server 2012. Основное его отличие от обычного,
                "реляционного", классического (rowstore) заключается в способе формирования и в форме хранения.<br />
                На одной таблице может быть создан только один колоночный индекс.<br />
                При создании обычного индекса группируются и сохраняются данные для строк. Для индекса columnstore
                выполняется группировка и сохранение данных для столбцов. При этом выполняется сжатие данных. Кроме
                того, индекс может создаваться только для таблиц, но не для представлений. Данные таблицы, для которой
                создан индекс columnstore, не могут быть изменены. <br />
                Для некоторых типов запросов к базе такая структура индекса может сильно повысить производительность.
                Подобные запросы часто используются при работе с так называемыми хранилищами данных.<br />
                В индекс могут быть включены типы данных: строковые, числовые, даты и времени. Нельзя включать
                разреженные столбцы. Индекс не может содержать более 1024 столбцов.
            </div>
        </li>
        <li>
            <div class="questiion" id="xmlindex">Расскажите про XML index?</div>
            <div>
                <b>XML-индекс</b> индексирует все теги, значения и пути хранимые в столбце экземпляров XML. Для одной таблицы
                можно создать до 249 индексов XML.<br />
                XML-индексы разделяются на следующие категории.<br />
                <b>Первичный</b> XML-индекс<br />
                <b>Вторичные</b> XML-индексы.<br />
                <b>Первичный XML-индекс</b><br />
                При создании первичного XML-индекса индексируются все теги, значения и пути в экземплярах XML,
                хранимых в XML-столбце. Чтобы создать первичный XML-индекс, таблица, содержащая соответствующий
                XML-столбец, должна иметь кластеризованный индекс первичного ключа таблицы.<br />
                <b>ВторичныеXML-индексы</b><br />
                Перед созданием вторичных индексов должен существовать первичный XML-индекс. Существуют следующие типы
                вторичных индексов: PATH, VALUE, PROPERTY<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="otherindexes">Какие еще типы индексов вы знаете?</div>
            <div>
                <b>Составной индекс</b><br />
                Такой индекс может содержать более одного столбца. Вы можете включить до 16 столбцов в индекс, но их
                общая длина ограничена 900 байтами. Как кластеризованный, так и некластеризованный индексы могут быть
                составными.<br />
                <b>Уникальный индекс</b><br />
                Такой индекс обеспечивает уникальность каждого значения в индексируемом столбце.<br />
                <b>Покрывающий индекс</b><br />
                Такой индекс позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без
                дополнительных обращений к записям самой таблицы.<br />
                <b>Фильтрованный индекс</b><br />
                В операторе создания индекса можно указать предложение WHERE, которое определяет создание
                "фильтрованного" индекса. В состав, которого включаются не все строки таблицы, а только те, которые
                отвечают условиям, заданным в этом предложении. Такой фильтрованный индекс не может быть кластерным.
            </div>
        </li>
        <li>
            <div class="questiion" id="constraint">
                Что такое Constraint? Какие Constraint вам известны и какую роль они выполняют?
            </div>
            <div>
                - <b>Constraint</b> – универсальное средство, с помощью которого можно задать правила, которым должны
                удовлетворять данные, для возможности записи в поле. Если записываемое значение не удовлетворяет
                ограничениям, назначенным полю, то запись завершается ошибкой. Таким образом, сервер сам будет
                контролировать целостность данных, вводимых пользователем.<br>
                - <b>NOT NULL</b> - Indicates that a column cannot store NULL value<br>
                - <b>UNIQUE</b> - Ensures that each row for a column must have a unique value<br>
                - <b>PRIMARY KEY</b> - A combination of a NOT NULL and UNIQUE. Ensures that a column (or combination of two or
                more columns) have a unique identity which helps to find a particular record in a table more easily and
                quickly<br>
                - <b>FOREIGN KEY</b> - Ensure the referential integrity of the data in one table to match values in another
                table<br>
                - <b>CHECK</b> - Ensures that the value in a column meets a specific condition<br>
                - <b>DEFAUL</b>T - Specifies a default value for a column<br>
            </div>
        </li>
        <li>
            <div class="questiion" id="triggers">Что такое триггеры?</div>
            <div>
                <b>Три́ггер (англ. trigger)</b> — это хранимая процедура особого типа, которую пользователь не вызывает
                непосредственно, а исполнение которой обусловлено действием по модификации данных: добавлением INSERT,
                удалением DELETE строки в заданной таблице, или изменением UPDATE данных в определённом столбце
                заданной таблицы. Могут выполняться как до операции, так и после.
            </div>
        </li>
        <li>
            <div class="questiion" id="joins">Что такое LEFT JOIN, RIGHT JOIN, INNER JOIN, CROSS JOIN</div>
            <div>
                Объеденяет таблицы для получения результатов<br/>
				SELECT * FROM Table1 t1<br/>
				(LEFT/RIGHT/INNER) JOIN Table2 t2 ON t1.ID = t2.ID<br/>
				SELECT * FROM Table1 t1<br/>
				CROSS JOIN Table2 t2<br/>
				Результат:<br/>
				<b>LEFT</b>Все строки из t1, из t2, те что соответствуют ON или NULL<br/>
				<b>RIGHT</b>Все строки из t2, из t1, те что соответствуют ON или NULL<br/>
				<b>INNER</b>Те строки из t1 и t2, что соответствуют ON<br/>
				<b>CROSS</b>Каждой строке из t1, соответствуют все строки из t2<br/>				
            </div>
        </li>
        <li>
            <div class="questiion" id="hints">Для чего нужны hints (подсказки или указания) в sql?</div>
            <div>
                Подсказка в языке SQL (англ. hint) — средство, позволяющее явным образом влиять на план запроса.
                Выделяются следующие назначения подсказок:<br />
                указание порядка соединения таблиц<br />
                указание метода соединения таблиц<br />
                указание конкретного индекса для доступа к таблице<br />

                SELECT *<br />
                FROM Customers C WITH (INDEX=City)<br />
                INNER LOOP JOIN Orders O ON O.CustomerID = C.CustomerID<br />
                WHERE C.City = 'Madrid'<br />
                фигурируют две подсказки:<br />
                LOOP — указывает, что соединять таблицы следует методом вложенных циклов<br />
                WITH (INDEX=City) — указывает, что для доступа к таблице Customers следует использовать индекс с названием City
            </div>
        </li>
        <li>
            <div class="questiion" id="scantable">Что такое Full Table Scan? Как этого можно избежать?</div>
            <div>
                Последовательный поиск данных, может занимать довольно долгое время влияя негативно на производительность.
            </div>
        </li>
        <li>
            <div class="questiion" id="sqltransaction">Что дает SQL транзакция?</div>
            <div>
                <b>Транзакция</b> – это последовательность операций, которые должны быть или все выполнены или все не
                выполнены (все или ничего).
            </div>
        </li>
        <li>
            <div class="questiion" id="denormalization">
                Для чего используется денормализация базы данных?
                Приходилось ли вам денормализировать базу данных?
            </div>
            <div>Чтобы избежать JOIN’ов</div>
        </li>
         <li>
            <div class="questiion" id="computedcolumn">
                Расскажите, из чего состоит строка в таблице, содержащей две колонки типа nvarchar и int?
                Какие дополнительные данные содержатся в этой строке?
            </div>
            <div>
                ??? Вычисляемый столбец <b>(computed column)</b>. Int нужно будет приводить к nvarchar
            </div>
        </li>       
		<li>
            <div class="questiion">Какая структура (архитектура) .mdl файла?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Как хранятся таблицы в .mdl файлах?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое Extent?</div>
            <div></div>
        </li>
    </ul>

    <div class="theme" id="patternsquestion">Вопросы по шаблонам проектирования</div>
    <div>
        <a href="#spagettycode">Что такое Spagetty Code?</a><br />
        <a href="#raviolicode">Что такое Ravioli code?</a><br />
        <a href="#spagettycode">Что такое Lasagna code?</a><br />
        <a href="#typeofpatterns">Какие шаблоны проектирования известны?</a><br />
        <a href="#factory">Что такое фабрика?</a><br />
        <a href="#strategy">Что такое стратегия?</a><br />
        <a href="#adapter">Что такое адаптер?</a><br />
        <a href="#dependencyinjection">Что такое Dependency Injection?</a><br />
        <a href="#ioc">Что такое IoC?</a><br />
        <a href="#publishersubscriber">
            Реализацией какого паттерна являются события в .NET? (Publisher - Subscriber)
        </a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
		<li>
            <div class="questiion" id="spagettycode">Что такое Spagetty Code?</div>
            <div>
                <b>Спагетти-код</b> — плохо спроектированная, слабо структурированная, запутанная и трудная для понимания
                программа. <br />
                Спагетти-код назван так, потому что ход выполнения программы похож на миску спагетти, то есть
                извилистый и запутанный.
            </div>
        </li>
        <li>
            <div class="questiion" id="raviolicode">Что такое Равиоли-код?</div>
            <div>
                <b>Равиоли-код</b> — код, состоящий из огромного числа независимых компонентов, и чтобы понять, как исправить ошибку на стыке компонентов, надо «прорываться» через межкомпонентные интерфейсы.
            </div>
        </li>
        <li>
            <div class="questiion" id="pahlavacode">Что такое Пахлава-код или лазанья-код?</div>
            <div>
                <b>Пахлава-код</b> или <b>лазанья-код</b> — код, в котором слишком много (для данной задачи) слоёв абстракции.
            </div>
        </li>
        <li>
            <div class="questiion" id="typeofpatterns">Какие шаблоны проектирования известны?</div>
            <div>
                <table>
                    <tr>
                        <th>Поведенчиские (Behavioral)</th>
                        <td>Chain Of Responsibility</td>
                        <td>Command</td>
                        <td>Interpreter</td>
                        <td>Iterator</td>
                        <td>Mediator</td>
                        <td>Memento</td>
                        <td>Observer</td>
                        <td>Strategy</td>
                        <td>Template Method</td>
                        <td>State</td>
                        <td>Visor</td>
                    </tr>
                    <tr>
                        <th>Порождающие (Creational)</th>
                        <td>Abstract factory</td>
                        <td>Builder</td>
                        <td>Factory Method</td>
                        <td>Prototype</td>
                        <td>Singleton</td>
                    </tr>
                    <tr>
                        <th>Структурные (Structural)</th>
                        <td>Adapter</td>
                        <td>Bridge</td>
                        <td>Composite</td>
                        <td>Decorator</td>
                        <td>Facade</td>
                        <td>Flyweight(приспособленец)</td>
                        <td>Proxy</td>
                    </tr>
                </table>
            </div>
        </li>
        <li>
            <div class="questiion" id="factory">Что такое фабрика?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion" id="strategy">Что такое стратегия?</div>
            <div>
                <b>Стратегия (англ. Strategy)</b> — поведенческий шаблон проектирования, предназначенный для определения
                семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет
                выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять
                выбранный алгоритм независимо от объектов-клиентов, которые его используют.
            </div>
        </li>
        <li>
            <div class="questiion" id="adapter">Что такое адаптер?</div>
            <div>
                <b>Адаптер (англ. Adapter)</b> — структурный шаблон проектирования, предназначенный для организации
                использования функций объекта, недоступного для модификации, через специально созданный интерфейс.
                Имеется посредник, кт. выдает поведение вспомогательного класса, за основное
            </div>
        </li>
        <li>
            <div class="questiion" id="dependencyinjection">Что такое Dependency Injection?</div>
            <div>
                Внедрения зависимости позволяет нам автоматически вытянуть из IoC-контейнера нужные нам зависимости
                при инициализации.
            </div>
        </li>
        <li>
            <div class="questiion" id="ioc">Что такое IoC?</div>
            <div>
                <b>Inversion of Control (инверсия управления)</b> - это паттерн, в котором управление временем жизни объекта
                поручено какой-то компоненте. Вместо того чтобы создавать объект самим (через new()) мы запрашиваем
                его у т.н. IoC-контейнера, то есть у фабрики, которая умеет грамотно производить объекты.
            </div>
        </li>
        <li>
            <div class="questiion" id="publishersubscriber">
                Реализацией какого паттерна являются события в .NET? (Publisher - Subscriber)
            </div>
            <div>Observer(Наблюдатель)</div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion">
            </div>
            <div></div>
        </li>
    </ul>

    <div class="theme" id="testingquestion">Вопросы по Unit Tests</div>
    <div>
        <a href="#typeoftest">Виды тестирования?</a><br />
        <a href="#unittests">Для чего нужны Unit tests?</a><br />
        <a href="#mock">Что такое Mock объект?</a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="typeoftest">Виды тестирования?</div>
            <div>
                <b>Блочное (модульное, unit testing)</b> - тестирование наиболее понятное для программиста. Фактически
                это тестирование методов какого-то класса программы в изоляции от остальной программы.<br />
                <b>Интеграционное (Integration Testing)</b> — тестирование взаимодействия нескольких классов, выполняющих
                вместе какую-то работу.<br />
                <b>Системное (System Testing)</b> — тестирование программы в целом.
            </div>
        </li>
        <li>
            <div class="questiion" id="unittests">Для чего нужны Unit tests?</div>
            <div>Для тестирования методов какого-то класса</div>
        </li>
        <li>
            <div class="questiion" id="mock">Что такое Mock объект?</div>
            <div>
                <b>Mock-объект</b> представляет собой конкретную фиктивную реализацию интерфейса, предназначенную
                исключительно для тестирования взаимодействия и относительно которого высказывается утверждение.
            </div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
    </ul>

    <div class="theme" id="mvcquestion">Вопросы по ASP.NET MVC</div>
    <div>
        <a href="#aboutmvc">
            Что такое MVC? Рассказать про архитектуру ASP.NET MVC (action методы, вьюхи, контроллеры,
            общий цикл жизни запроса).
        </a><br />
        <a href="#webconfig">Для чего служит web.config?</a><br />
        <a href="#globalasax">Для чего используется Global.asax?</a><br />
        <a href="#routes">Что такое роуты? Как они используются?</a><br />
        <a href="#areas">Что такое Area?</a><br />
        <a href="#getvspost">В чем разница между GET и POST запросами?</a><br />
        <a href="#viewbagvsviewdatavstempdatavssession">В чем разница между ViewBag, ViewData, TempData и Session?</a><br />
        <a href="#mvcEngines">Какие движки представлений есть в MVC?</a><br />
        <a href="#iviewengine">Как реализовать движок представления?</a><br />
        <a href="#dotnetquestion">texthere</a><br />
        <a href="#dotnetquestion">texthere</a><br />
        <a href="#aaaa"></a>    <br />
    </div>
    <ul>
        <li>
            <div class="questiion" id="aboutmvc">
                Что такое MVC? Рассказать про архитектуру ASP.NET MVC (action методы, вьюхи, контроллеры, общий цикл
                жизни запроса).
            </div>
            <div>
                <b>Методы действий (action methods)</b> представляют такие методы контроллера, которые обрабатывают запросы по
                определенному URL. Методы действий всегда имеют модификатор public.<br/> 
				В ASP.NET MVC framework <b>контроллеры</b> – это .NET классы, содержащие логику, необходимую для обработки 
				запроса. Роль контроллера заключается в инкапсуляции логики приложения. Это обозначает, что контроллеры 
				отвечают за обработку входящих запросов, выполняя операции по доменной модели и выбирая представления для 
				отображения пользователю.<br/>
            </div>
        </li>
        <li>
            <div class="questiion" id="webconfig">Для чего служит web.config?</div>
            <div>
                <b>Web.config</b> — это XML-документ, определяющий параметры для ASP.NET web-приложения.
            </div>
        </li>
        <li>
            <div class="questiion" id="globalasax">Для чего используется Global.asax?</div>
            <div>
				<b>Файл Global.asax.cs</b> устанавливает некоторые из основных функциональных возможностей MVC при запуске
				приложения. При первом запуске приложения вызывается Application_start() который устанавливает эти 
				возможности.				 
            </div>
        </li>
        <li>
            <div class="questiion" id="routes">Что такое роуты? Как они используются?</div>
            <div>
                <b>Роут</b> - объект который предоставляет свойства и методы для определения маршрута и получения
                сведений о маршруте в ASP.NET.
            </div>
        </li>
        <li>
            <div class="questiion" id="areas">Что такое Area?</div>
            <div>
                <div class="link"> https://www.youtube.com/watch?v=sQdapgqM8-8 </div>
                Для размещения крупных проектов платформа ASP.NET MVC позволяет разделять веб-приложений на более
                мелкие модули, называемые областями. Области позволяют разделить крупное веб-приложение MVC на более
                мелкие функциональные группы. Область является структурой MVC, расположенной внутри приложения.
                Приложение может содержать несколько структур MVC (областей).<br />
            </div>
        </li>
        <li>
            <div class="questiion" id="getvspost">В чем разница между GET и POST запросами?</div>
            <div>
                Негласное правило гласит, что запросы GET следует использовать для получения информации «только для
                чтения» (read-only), в то время как POST запросы должны быть использованы для любой операции, которая
                изменяет состояние приложения. В терминах стандартизации, GET запросы служат для безопасного
                взаимодействия (только для получения информации), а POST запросы для небезопасного взаимодействия
                (принятие решения или изменение чего-то).
            </div>
        </li>
        <li>
            <div class="questiion" id="viewbagvsviewdatavstempdatavssession">
                В чем разница между ViewBag, ViewData, TempData и Session?
            </div>
            <div>
                Все эти объекты предназначены для передачи данных из контроллера в представление.<br />
                <div class="link"> https://www.youtube.com/watch?v=orhZoGslBm8 </div>
                <b>ViewBag</b> является динамическим объектом и создаваемые новые свойства, просто устанавливают их
                значения.<br />
                ViewBag — объект с типом dynamic, кт. позволяет создавать динамически новые свойства и просто
                устанавливать их значения. Является Wrapper’ом объекта ViewData.<br />
                — Жизненный цикл также ограничивается текущий запросом;<br />
                — При редиректе значение также оборачивается в null;<br />
                — Нет необходимости в приведении типов для получения данных<br />
                — Так же, ViewBag имеет преимущество в том, что можно использовать его свойства Strongly typed-методом,
                при этом корректность данных будет проверена еще на этапе компиляции/написания кода.<br />
				<b>ViewData</b> — это словарный объект, производный от TempViewDataDictionary;<br />
                — Используется для передачи данных из контроллера в соответствующее представление;<br />
                — Жизненный цикл ограничен текущим запросом;<br />
                — Если происходит redirect, значение ViewData превращается в null;<br />
                — Также необходимо осуществлять приведение типов и проверять на null, чтобы избежать ошибок;<br />
                <b>TempData</b> представляет словарь, хранящий пары ключ-значение, как и ViewData. TempData позволяет
                сохранять переданное значение в течении всего текущего запроса.<br />
                — Сохранение данных между запросами<br />
                — Время жизни: текущий и следующий запрос<br />
                — Данные после первого прочтения удаляются<br />
                — При использовании Peek("Key") данные не удаляются.<br />
                — После использования данных сделать следующее => @{ TempData.Keep("MyData"); }<br />
                <b>Session</b> <br />
                <div class="link">http://www.cyberguru.ru/microsoft-net/asp-net/aspnet-session-exploration.html?showall=1</div>
                Интернет не сохраняет состояние, а значит, новый экземпляр класса веб-страницы вновь создается
                при каждой отправке страницы на сервер. Как известно, HTTP - протокол без сохранения состояния, он не
                способен хранить клиентскую информацию о странице. Если пользователь вставит какие-то данные и
                перейдет на следующую страницу, то эти данные потеряются, и пользователь не сможет извлечь данные.
                Что нужно? Нужно хранить информацию. Сессия позволяет хранить информацию в памяти сервера. Она
                поддерживает хранение любого типа объекта наряду с пользовательским объектом. Для каждого клиента
                данные сессии хранятся отдельно, то есть данные сессии хранятся согласно клиенту.<br />
                — Сохранение данных между запросами<br />
                — Данные хранятся определенное время. Настраивается в web.config’е.<br />
                <b> &lt;system.web&gt;&lt;sessionState mode="InProc" timeout="1" /&gt;&lt;/system.web&gt; </b>
            </div>
        </li>
        <li>
            <div class="questiion" id="mvcEngines">Какие движки представлений есть в MVC?</div>
            <div>
				<b>Движок Razor</b> появился в третьей версии MVC.<br/>
				<b>Движок ASPX</b> он же движок представлений <b>Web Forms</b>, использует синтаксис тегов <b>Web Forms 
				<% ...%></b>. Он используется для поддержки совместимости в старых приложениях MVC. 
			</div>
        </li>
		<li><b></b>
            <div class="questiion" id="iviewengine">Как реализовать движок представления?</div>
            <div>
				Движки представлений реализуют интерфейс IViewEngine.</br/>
				namespace System.Web.Mvc</br/>
				{</br/>
					public interface IViewEngine</br/>
					{</br/>
						ViewEngineResult FindPartialView(ControllerContext controllerContext,</br/>
						  string partialViewName,</br/>
						  bool useCache);</br/>
						ViewEngineResult FindView(ControllerContext controllerContext,</br/>
						  string viewName,</br/>
						  string masterName,</br/>
						  bool useCache);</br/>
						void ReleaseView(ControllerContext controllerContext, IView view);</br/>
					}</br/>
				}</br/>
			</div>
        </li>
		<li>
            <div class="questiion"></div>
            <div></div>
        </li>
		<li>
            <div class="questiion">Что такое Cookie?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое ModelState?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое Request, Response?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Какие аттрибуты можно использовать в моделях и зачем?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion">Что такое Claims? Для чего используются?</div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
        <li>
            <div class="questiion"></div>
            <div></div>
        </li>
    </ul>
</body>
</html>
